<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>初探操作系统 | Zy`s Blog</title><meta name="keywords" content="计算机基础,操作系统"><meta name="author" content="ZouYe"><meta name="copyright" content="ZouYe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言操作系统是大三下学期学习完的，可以称得上是我整个大学期间最痛苦的一门专业课了。 主要痛点在于很多知识点非常的抽象，你没有办法去通过真实的操作掌握这些知识，即便可以理解，也很难深入，很容易忘记。 但是和计算机网络一样，这门课也是非常重要的，即使我现在并不知道他实际作用，但肯定会对以后的学习工作产生深远影响。 所以还是按照惯例整理了一下资料信息，方便之后查看同时也加深自己的理解。  参考资料 [计">
<meta property="og:type" content="article">
<meta property="og:title" content="初探操作系统">
<meta property="og:url" content="https://satoshi1130.github.io/MyBlog/2020/12/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="Zy&#96;s Blog">
<meta property="og:description" content="前言操作系统是大三下学期学习完的，可以称得上是我整个大学期间最痛苦的一门专业课了。 主要痛点在于很多知识点非常的抽象，你没有办法去通过真实的操作掌握这些知识，即便可以理解，也很难深入，很容易忘记。 但是和计算机网络一样，这门课也是非常重要的，即使我现在并不知道他实际作用，但肯定会对以后的学习工作产生深远影响。 所以还是按照惯例整理了一下资料信息，方便之后查看同时也加深自己的理解。  参考资料 [计">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img1.baidu.com/it/u=717294809,2494697366&fm=26&fmt=auto&gp=0.jpg">
<meta property="article:published_time" content="2020-12-29T05:49:18.000Z">
<meta property="article:modified_time" content="2021-09-06T10:29:32.893Z">
<meta property="article:author" content="ZouYe">
<meta property="article:tag" content="计算机基础">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img1.baidu.com/it/u=717294809,2494697366&fm=26&fmt=auto&gp=0.jpg"><link rel="shortcut icon" href="/MyBlog/img/favicon.png"><link rel="canonical" href="https://satoshi1130.github.io/MyBlog/2020/12/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/MyBlog/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/MyBlog/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: ZouYe","link":"链接: ","source":"来源: Zy`s Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '初探操作系统',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-09-06 18:29:32'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://gitee.com/Satoshi1130/picture/raw/master/cover/%E7%94%B7%E7%94%9F%E5%A4%B4%E5%83%8F1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/MyBlog/archives/"><div class="headline">文章</div><div class="length-num">3</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/MyBlog/tags/"><div class="headline">标签</div><div class="length-num">4</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/MyBlog/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/MyBlog/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/MyBlog/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/MyBlog/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/MyBlog/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/MyBlog/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/MyBlog/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://img1.baidu.com/it/u=717294809,2494697366&amp;fm=26&amp;fmt=auto&amp;gp=0.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/MyBlog/">Zy`s Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/MyBlog/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/MyBlog/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/MyBlog/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/MyBlog/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/MyBlog/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/MyBlog/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">初探操作系统</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-12-29T05:49:18.000Z" title="发表于 2020-12-29 13:49:18">2020-12-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-09-06T10:29:32.893Z" title="更新于 2021-09-06 18:29:32">2021-09-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/MyBlog/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE/">专业课</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="初探操作系统"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>操作系统是大三下学期学习完的，可以称得上是我整个大学期间最痛苦的一门专业课了。</p>
<p>主要痛点在于很多知识点非常的抽象，你没有办法去通过真实的操作掌握这些知识，即便可以理解，也很难深入，很容易忘记。</p>
<p>但是和计算机网络一样，这门课也是非常重要的，即使我现在并不知道他实际作用，但肯定会对以后的学习工作产生深远影响。</p>
<p>所以还是按照惯例整理了一下资料信息，方便之后查看同时也加深自己的理解。</p>
<hr>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>[计算机操作系统（第四版）——西安电子科技大学出版社</li>
<li><a target="_blank" rel="noopener" href="http://www.cyc2018.xyz/">CS-Notes</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/FaHKGRI69TqDj0AJtNiVoA">进程和线程基础知识全家桶，30张图一套带走</a></li>
</ol>
<hr>
<h1 id="基础知识——概述"><a href="#基础知识——概述" class="headerlink" title="基础知识——概述"></a>基础知识——概述</h1><h2 id="操作系统基本简介"><a href="#操作系统基本简介" class="headerlink" title="操作系统基本简介"></a>操作系统基本简介</h2><h3 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h3><p><strong>操作系统是配置在计算机硬件上的第一层软件</strong>，是对硬件系统的首次扩充。其主要作用是管理好这些设备，提高它们的利用率和系统的吞吐量，并为用户和应用程序提供一个简单的接口，便于用户使用。</p>
<h3 id="操作系统的目标"><a href="#操作系统的目标" class="headerlink" title="操作系统的目标"></a>操作系统的目标</h3><p>在计算机系统上配置操作系统，其主要目标是：方便性，有效性，可扩充性和开放性。</p>
<ol>
<li>方便性：一个未配置OS的计算机系统使极难使用的。用户如果想直接在计算机硬件（裸机）上运行自己所编写的程序，就必须用机器语言书写程序。但如果在计算机硬件上配置了OS，系统便可以使用编译命令将用户采用高级语言书写的程序翻译成机器代码，或者直接通过OS提供的各种命令操纵计算机系统。</li>
<li>有效性：第一层含义是提高系统资源的利用率，第二层含义是提高系统的吞吐量。</li>
<li>可扩充性：为适应计算机硬件、体系结构以及计算机应用发展的要求，OS必须具有很好的可扩充性。</li>
<li>开放性：指系统能遵循世界标准规范，特别是遵循开放系统互连OSI国际标准。</li>
</ol>
<h3 id="操作系统的主要功能"><a href="#操作系统的主要功能" class="headerlink" title="操作系统的主要功能"></a>操作系统的主要功能</h3><p>一般来说，现代操作系统主要提供下面几种功能。</p>
<ul>
<li>进程管理: 进程管理的主要作用就是任务调度，在单核处理器下，操作系统会为每个进程分配一个任务，进程管理的工作十分简单；而在多核处理器下，操作系统除了要为进程分配任务外，还要解决处理器的调度、分配和回收等问题。</li>
<li>内存管理：内存管理主要是操作系统负责管理内存的分配、回收，在进程需要时分配内存以及在进程完成时回收内存，协调内存资源，通过合理的页面置换算法进行页面的换入换出。</li>
<li>设备管理：根据确定的设备分配原则对设备进行分配，使设备与主机能够并行工作，为用户提供良好的设备使用界面。</li>
<li>文件管理：有效地管理文件的存储空间，合理地组织和管理文件系统，为文件访问和文件保护提供更有效的方法及手段。</li>
<li>提供用户接口：操作系统提供了访问应用程序和硬件的接口，使用户能够通过应用程序发起系统调用从而操纵硬件，实现想要的功能。</li>
</ul>
<hr>
<h1 id="基础知识——进程和线程"><a href="#基础知识——进程和线程" class="headerlink" title="基础知识——进程和线程"></a>基础知识——进程和线程</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h3><p>并发是指两个或多个事件在同一时间间隔内发生，并行是指两个或多个事件在同一时刻发生。</p>
<p>在多道程序环境下，并发性指一段时间内宏观上有多个程序在同时运行，但在单处理机系统中，每一时刻却仅能有一道程序执行，故微观上这些程序只能是分时地交替执行</p>
<p>倘若计算机系统有多个处理器，这些可以并发执行的程序便可被分配到多个处理机上，实现并行执行，即利用每个处理机来处理一个可并发执行的程序。</p>
<p><img src="https://gitee.com/Satoshi1130/picture/raw/master/cover/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C.jpg" alt="操作系统-并发与并行"></p>
<h3 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h3><p>对于进程的定义，从不同的角度可以有不同的定义，其中较典型的定义有下面三种。</p>
<ol>
<li>进程是程序的一次执行。 </li>
<li>进程是一个程序及其数据在处理机上顺序执行时所发生的活动。</li>
<li>进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。</li>
</ol>
<h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><blockquote>
<p>多个进程在并发执行时共享系统资源，致使它们在运行过程中呈现间断性的运行规律，所以进程在其生命周期内可能具有多种状态。</p>
</blockquote>
<p>一般而言，每一个进程至少处于下面五种基本状态之一。</p>
<ol>
<li>运行状态（<em>Running</em>）：该时刻进程占用 CPU。</li>
<li>就绪状态（<em>Ready</em>）：可运行，但因为其他进程正在运行而暂停停止。</li>
<li>阻塞状态（<em>Block</em>）：该进程正在等待某一事件发生（如等待输入/输出操作的完成）而暂时停止运行，这时，即使给它CPU控制权，它也无法运行。</li>
<li>创建状态（<em>New</em>）：进程正在被创建时的状态。</li>
<li>结束状态（<em>Exit</em>）：进程正在从系统中消失时的状态。</li>
</ol>
<p><img src="https://gitee.com/Satoshi1130/picture/raw/master/cover/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BA%94%E7%A7%8D%E7%8A%B6%E6%80%81.jpg" alt="操作系统-进程的五种状态"></p>
<h3 id="进程的挂起操作"><a href="#进程的挂起操作" class="headerlink" title="进程的挂起操作"></a>进程的挂起操作</h3><blockquote>
<p>在许多系统中，进程除了就绪、运行和阻塞三种最基本的状态外，为了系统和用户观察和分析进程的需要，还引入了一个对进程的重要操作——挂起操作。</p>
</blockquote>
<p>挂起操作作用于某个进程时，该进程将被挂起（调至外存等待），意味着此时该进程处于静止状态。如果进程正在执行，它将暂停执行。若原本处于就绪状态，则该进程此时暂不接受调度。与挂起操作对应的是激活操作。</p>
<h3 id="挂起操作的引入原因"><a href="#挂起操作的引入原因" class="headerlink" title="挂起操作的引入原因"></a>挂起操作的引入原因</h3><p>引入挂起操作的原因，是基于系统和用户的如下需要。</p>
<ol>
<li>终端用户的需要。当终端用户在自己的程序运行期间发现有可疑问题，希望暂停自己的程序的运行，使之停止下来，以便用户研究其执行情况或对程序进行修改。</li>
<li>父进程请求。有时父进程希望挂起自己的某个子进程，以便考察和修改该子进程，或者协调各子进程间的活动。</li>
<li>负荷调节的需要。当实时系统中的工作负荷较重，已可能影响到对实时任务的控制时，可由系统把一些不重要的进程挂起，以保证系统能正确运行。</li>
<li>操作系统的需要。操作系统有时希望挂起某些进程，以便检查运行中的资源使用情况或进行记账。</li>
</ol>
<h3 id="挂起操作后五个基本进程状态的转换"><a href="#挂起操作后五个基本进程状态的转换" class="headerlink" title="挂起操作后五个基本进程状态的转换"></a>挂起操作后五个基本进程状态的转换</h3><p><img src="https://gitee.com/Satoshi1130/picture/raw/master/cover/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%8C%82%E8%B5%B7%E6%93%8D%E4%BD%9C%E5%90%8E%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E8%BD%AC%E6%8D%A2.jpg" alt="操作系统-挂起操作后进程状态的转换"></p>
<h3 id="进程的控制结构——进程控制块"><a href="#进程的控制结构——进程控制块" class="headerlink" title="进程的控制结构——进程控制块"></a>进程的控制结构——进程控制块</h3><blockquote>
<p>一方面，为了方便对计算机中的各类资源（包括硬件和信息）的使用和管理，OS将他们抽象为相应的各种数据结构，以及提供一组对资源进行操作的命令，用户可利用这些数据结构及操作命令来执行相关的操作，而无需关心其实现的具体细节。</p>
<p>另一方面，操作系统作为计算机资源的管理者，尤其是为了协调诸多用户对系统中共享资源的使用，它还必须记录和查询各种资源的使用及各类进程运行情况的信息。OS对于这些信息的组织和维护也是通过建立和维护各种数据结构的方式来实现的。</p>
</blockquote>
<p>在操作系统中，是用进程控制块（process control block，PCB）数据结构来描述进程的，<strong>PCB是进程存在的唯一标识</strong>，这意味着一个进程的存在，必然会有一个PCB，如果进程消失了，那么PCB也会随之消失。</p>
<p>PCB主要包括四个方面的信息。</p>
<ol>
<li><p>进程标识符：用于唯一地标识一个进程，一般有两种标识符。</p>
<ul>
<li><strong>外部标识符</strong>：为了方便用户对进程的访问，须为每一个进程设置一个外部标识符。它是由创建者提供的，通常由字母、数字组成。为了描述进程的家族关系，还应该设置父进程标识及子进程标识。此外还可设置用户标识，以指示拥有该进程的用户。</li>
<li><strong>内部标识符</strong>：为了方便系统对进程的使用，在OS种又为进程设置了内部标识符，即赋予每一个进程一个唯一的数字标识符，它通常是一个进程的序号。</li>
</ul>
</li>
<li><p>处理机状态：处理机状态信息也称为处理机的上下文，主要是由处理机的各种寄存器中的内容组成的。例如：通用寄存器、指令计数器、程序状态字PSW、用户栈指针。</p>
</li>
<li><p>进程调度信息：在OS进行调度时，必须了解进程的状态及有关进程调度的信息。例如：进程状态、进程优先级、进程调度所需的其它信息（例如调度算法需要信息）、事件（即阻塞原因）。</p>
</li>
<li><p>进程控制信息：是指用于进程控制所必须的信息。例如：程序和数据的地址、进程的同步和通信机制、资源清单、链接指针。</p>
</li>
</ol>
<blockquote>
<p>进程控制是进程管理中最基本的功能，主要包括创建新进程、终止已完成的进程、将因发生异常情况而无法继续运行的进程置于阻塞状态、负责进程运行中的状态转换等功能。</p>
<p><strong>进程控制一般是由OS的内核中的原语来实现的</strong>。</p>
</blockquote>
<h3 id="系统态和用户态"><a href="#系统态和用户态" class="headerlink" title="系统态和用户态"></a>系统态和用户态</h3><p>为了防止OS本身及关键数据（如PCB——进程控制块等）遭受到应用程序有意或无意的破坏，通常也将处理机的执行状态分成系统态和用户态两种。</p>
<ul>
<li><p>系统态：又称管态，也称为内核态。它具有较高的特权，能执行一切指令，访问所有的寄存器和存储区，传统的OS都在系统态运行。</p>
</li>
<li><p>用户态：又称目态。它具有较低特权的执行状态，仅能执行规定的指令，访问指定的寄存器和存储区。一般情况下，应用程序只能在用户态运行，不能去执行OS指令及访问OS区域，这样可以防止应用程序对OS的破坏。</p>
</li>
</ul>
<h3 id="系统态和用户态的转换方式"><a href="#系统态和用户态的转换方式" class="headerlink" title="系统态和用户态的转换方式"></a>系统态和用户态的转换方式</h3><p>处理器从用户态切换到内核态的方法有三种：系统调用、内中断、外中断。</p>
<ol>
<li>系统调用：是操作系统的最小功能单位，是操作系统提供的用户接口，系统调用本身是一种软中断。</li>
<li>内中断：也叫做异常，是由错误引起的，如文件损坏、缺页故障等。</li>
<li>外中断：是通过两根信号线来通知处理器外设的状态变化，是硬中断。</li>
</ol>
<h3 id="临界区是什么"><a href="#临界区是什么" class="headerlink" title="临界区是什么"></a>临界区是什么</h3><p>要知道临界区，首先要知道临界资源，举的例子就是打印机，磁带机之类的，诸进程之间应采取互斥的方式，实现对这种资源的共享。</p>
<p>不管是硬件临界资源还是软件临界资源，多个进程必须互斥地对他进行访问，人们把<strong>在每个进程中访问临界资源的那段代码</strong>称作临界区。</p>
<h3 id="进程同步机制应遵循的规则"><a href="#进程同步机制应遵循的规则" class="headerlink" title="进程同步机制应遵循的规则"></a>进程同步机制应遵循的规则</h3><p>为实现进程互斥地进入自己地临界区，可用软件方法，更多的是在系统中设置专门的同步机构来协调各进程间的运行。所有同步机制都应遵循下述四条准则。</p>
<ol>
<li>空闲让进（有效地利用临界资源）</li>
<li>忙则等待（保证对临界区的互斥访问）</li>
<li>有限等待（有限代表有限的时间，避免死等）</li>
<li>让权等待（当进程不能进入自己的临界区时，应该释放处理机，以免进程陷入“忙等”状态）</li>
</ol>
<h3 id="进程的同步方式"><a href="#进程的同步方式" class="headerlink" title="进程的同步方式"></a>进程的同步方式</h3><p>进程同步机制是对多个相关进程在执行次序上进行协调，使并发执行的诸进程之间能按照一定的规则（或时序）共享系统资源，并能很好地互相合作，从而使程序的执行具有可再现性。</p>
<p>单来分分成三种——硬件同步机制、信号量机制、管程机制。</p>
<ol>
<li>硬件同步机制：虽然可以利用软件方法解决诸进程互斥进入临界区的问题，但有一定难度，并且存在很大的局限性。目前许多计算机已提供了一些特殊的硬件指令，允许对一个字中的内容进行检测和修正，或者是对两个字的内容进行交换等。可利用这些特殊的指令来解决临界区问题。一共有三种实现：关中断、利用Test-and-Set指令实现互斥、利用Swap指令实现互斥（比如8086中的XCHG指令）。</li>
<li>信号量机制：Semaphores机制，目前信号量机制已被广泛地应用于单处理机、多处理机以及计算机网络中。最初是整型信号量，到记录型信号量，再到AND型信号量，以及后来的信号量集。</li>
<li>管程机制：虽然信号量机制是一种既方便，又有效的进程同步机制，但每个要访问临界资源的进程都必须自备同步操作wait和signal，这就使大量的同步操作分散在各个进程中。这样不仅给系统的管理带来了麻烦，还可能产生死锁问题，所以有了一种新的同步工具——管程。一个管程定义了一个数据结构和能为并发进程所执行（在该数据结构上）的一组操作，这组操作能同步进程和改变管程中的数据。</li>
</ol>
<h3 id="经典的进程同步问题——生产者与消费者问题"><a href="#经典的进程同步问题——生产者与消费者问题" class="headerlink" title="经典的进程同步问题——生产者与消费者问题"></a>经典的进程同步问题——生产者与消费者问题</h3><h3 id="经典的进程同步问题——哲学家进餐问题"><a href="#经典的进程同步问题——哲学家进餐问题" class="headerlink" title="经典的进程同步问题——哲学家进餐问题"></a>经典的进程同步问题——哲学家进餐问题</h3><h3 id="经典的进程同步问题——读者与写者问题"><a href="#经典的进程同步问题——读者与写者问题" class="headerlink" title="经典的进程同步问题——读者与写者问题"></a>经典的进程同步问题——读者与写者问题</h3><h3 id="进程的通信方式"><a href="#进程的通信方式" class="headerlink" title="进程的通信方式"></a>进程的通信方式</h3><blockquote>
<p>进程通信是指进程之间的信息交换。</p>
<p>进程的互斥和同步需要在进程间交换一定的信息，故不少学者将它们也归为进程通信，但只能把它们成为低级进程通信。在进程之间要传送大量数据时，应当利用OS提供的高级通讯工具。</p>
</blockquote>
<ul>
<li>共享存储器系统：相互通信的进程共享某些数据结构或共享存储区，进程之间能够通过这些空间进行通信。<ul>
<li>基于共享数据结构的通信方式。</li>
<li>基于共享存储区的通信方式 。</li>
</ul>
</li>
<li>管道通信系统：所谓“管道”，是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又名pipe文件，这种方式首创与UNIX系统。</li>
<li>消息传递系统：以格式化的消息为单位，将通信的数据封装在消息中，并利用操作系统提供的一组通信命令（原语），在进程间进行消息传递，完成进程间的数据交换，比如<strong>计算机网络里消息又被称为报文</strong>。因其实现方式的不同，可进一步分成如下两类。<ul>
<li>直接通信方式</li>
<li>间接通信方式。</li>
</ul>
</li>
<li>客户机-服务器系统：在网络环境的各种应用领域成为主流的通信实现机制。<ul>
<li>套接字（Socket）：最早是UNIX下的网络通信接口，为了解决多进程同时通信时端口和物理线路的多路复用问题。一个套接字就是一个通信标识类型的数据结构，包含了通信目的的地址、通信使用的端口号、传输层协议、进程所在的网络地址、以及针对客户或服务器程序提供的不同系统调用等</li>
<li>远程过程调用和远程方法调用：远程过程调用RPC（Remote Procedure Call），是个通信协议，用于通过网络连接的系统，允许运行于一台主机系统上的进程调用另一台主机系统上的进程，如果设计的软件采用面向对象编程，那么远程过程调用亦可称作远程方法调用</li>
</ul>
</li>
</ul>
<h3 id="进程同步与进程通信的区别"><a href="#进程同步与进程通信的区别" class="headerlink" title="进程同步与进程通信的区别"></a>进程同步与进程通信的区别</h3><p>进程同步与进程通信很容易混淆，它们的区别在于。</p>
<ul>
<li>进程同步：控制多个进程按一定顺序执行。</li>
<li>进程通信：进程间传输信息。</li>
</ul>
<p>进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。</p>
<h3 id="进程的上下文切换"><a href="#进程的上下文切换" class="headerlink" title="进程的上下文切换"></a>进程的上下文切换</h3><p>各个进程之间是共享 CPU 资源的，在不同的时候进程之间需要切换，让不同的进程可以在 CPU 执行，那么这个<strong>一个进程切换到另一个进程运行，称为进程的上下文切换</strong>。</p>
<h3 id="进程的上下文切换场景"><a href="#进程的上下文切换场景" class="headerlink" title="进程的上下文切换场景"></a>进程的上下文切换场景</h3><ol>
<li><strong>某个进程的CPU时间片耗尽</strong>：为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，就会被系统挂起，切换到其它正在等待 CPU 的进程运行。</li>
</ol>
<ul>
<li><strong>进程在系统资源不足时</strong>：比如内存不足时 要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行。</li>
<li><strong>进程主动挂起</strong>：当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度。</li>
<li><strong>更高优先级进程</strong>：当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行。</li>
<li><strong>硬件中断</strong>：发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序。</li>
</ul>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="线程是什么"><a href="#线程是什么" class="headerlink" title="线程是什么"></a>线程是什么</h3><p>线程是进程的一个实体，它是比进程更小的能独立运行的基本单位，是CPU调度和分派的基本单位。<strong>线程又被称作轻量级进程</strong>。</p>
<h3 id="进程和线程的比较"><a href="#进程和线程的比较" class="headerlink" title="进程和线程的比较"></a>进程和线程的比较</h3><ol>
<li>调度的基本单位：在没有线程的OS中，进程作为独立调度和分派的基本单位，是能独立运行的基本单位。在引入线程的OS中，线程作为调度和分派的基本单位，线程是能独立运行的基本单位。</li>
<li>并发性：在引入线程的OS中，不仅进程之间可以并发执行，在同一个进程中的多个线程之间亦可并发执行，当然不同的进程之间的线程也可以。</li>
<li>拥有资源：进程可以拥有资源，而线程没有（这里的没有其实是说仅仅保留最最基本的，必不可少的资源，比如（TCB——线程控制块，比如程序计数器））。允许多个线程共享该进程所拥有的资源。</li>
<li>独立性：同一进程中的不同线程之间的独立性要比不同进程之间的独立性低得多，因为同一进程的不同线程可以共享进程的内存地址空间和资源。</li>
<li>系统开销：进程开销很大，即指创建和撤销（系统要分配和回收PCB以及其他资源），也指进程上下文的切换（线程的上下文切换要远远快于进程）。</li>
<li>多处理机系统：单线程进程，不管有多少处理机，该进程也只能运行在一个处理机上，但多线程进程则可以将多个进程分配到多个处理机上。</li>
</ol>
<h3 id="用户级线程和内核级线程"><a href="#用户级线程和内核级线程" class="headerlink" title="用户级线程和内核级线程"></a>用户级线程和内核级线程</h3><blockquote>
<p>这个是指线程的实现方法，在不同的系统里面，线程的实现方式并不完全相同。</p>
</blockquote>
<p>**用户级线程(user level thread)**：对于这类线程，有关线程管理的所有工作都由应用程序完成，内核意识不到线程的存在。在应用程序启动后，操作系统分配给该程序一个进程号，以及其对应的内存空间等资源。应用程序通常先在一个线程中运行，该线程被成为主线程。在其运行的某个时刻，可以通过调用线程库中的函数创建一个在相同进程中运行的新线程。用户级线程的好处是非常高效，不需要进入内核空间，但并发效率不高。</p>
<p>**内核级线程(kernel level thread)**：对于这类线程，有关线程管理的所有工作由内核完成，应用程序没有进行线程管理的代码，只能调用内核线程的接口。内核维护进程及其内部的每个线程，调度也由内核基于线程架构完成。内核级线程的好处是，内核可以将不同线程更好地分配到不同的CPU，以实现真正的并行计算。</p>
<h3 id="用户级线程和内核级线程的组合方式"><a href="#用户级线程和内核级线程的组合方式" class="headerlink" title="用户级线程和内核级线程的组合方式"></a>用户级线程和内核级线程的组合方式</h3><blockquote>
<p>事实上，在现代操作系统中，往往使用组合方式实现多线程，即线程创建完全在用户空间中完成，并且一个应用程序中的多个用户级线程被映射到一些内核级线程上，相当于是一种折中方案。</p>
</blockquote>
<ol>
<li>多对一模型。将多个用户级线程映射到一个内核级线程上。该模型下，线程在用户空间进行管理，效率较高。缺点就是一个线程阻塞，整个进程内的所有线程都会阻塞。几乎没有系统继续使用这个模型。</li>
<li>一对一模型。将内核线程与用户线程一一对应。优点是一个线程阻塞时，不会影响到其它线程的执行。该模型具有更好的并发性。缺点是内核线程数量一般有上限，会限制用户线程的数量。更多的内核线程数目也给线程切换带来额外的负担。Linux和Windows操作系统家族都是使用一对一模型。</li>
<li>多对多模型。将多个用户级线程映射到多个内核级线程上。结合了多对一模型和一对一模型的特点。</li>
</ol>
<h3 id="进程同步与线程同步有什么区别"><a href="#进程同步与线程同步有什么区别" class="headerlink" title="进程同步与线程同步有什么区别"></a>进程同步与线程同步有什么区别</h3><p>进程之间地址空间不同，不能感知对方的存在，同步时需要将锁放在多进程共享的空间。</p>
<p>线程之间共享同一地址空间，同步时把锁放在所属的同一进程空间即可。</p>
<hr>
<h1 id="基础知识——处理机调度与死锁"><a href="#基础知识——处理机调度与死锁" class="headerlink" title="基础知识——处理机调度与死锁"></a>基础知识——处理机调度与死锁</h1><h2 id="处理机调度的概念"><a href="#处理机调度的概念" class="headerlink" title="处理机调度的概念"></a>处理机调度的概念</h2><blockquote>
<p>在多道程序系统中，调度的实质是一种资源分配，处理机调度是对处理机资源进行分配。处理机调度算法是指根据处理机从分配策略所规定的处理机分配算法。</p>
<p>在多道批处理系统中，一个作业从提交到获得处理机执行，直至作业运行完毕，可能需要经历多级处理机调度。</p>
</blockquote>
<h3 id="处理机调度的层次"><a href="#处理机调度的层次" class="headerlink" title="处理机调度的层次"></a>处理机调度的层次</h3><ol>
<li><p>高级调度（High Level Scheduling）</p>
<p>高级调度又称长程调度或<strong>作业调度</strong>，它的调度对象是作业。其主要功能是<strong>根据某种算法，决定将外存上处于后备队列中的哪几个作业调入内存，为它们创建进程、分配必要的资源，并将它们放入就绪队列</strong>。高级调度主要用于多道批处理系统，而在分时和实时系统中不设置高级调度。</p>
</li>
<li><p>低级调度（Low Level Scheduling）</p>
<p>低级调度又称为<strong>进程调度</strong>或短程调度，其所调度的对象是进程（或内核级线程）。其<strong>主要功能是根据某种算法，决定就绪队列中的哪个进程获得处理机，并由分派程序将处理机分配给被选中的进程</strong>。进程调度是最基本的一种调度，在多道批处理、分时和实时三种类型的OS中，都必须配置这级调度。</p>
</li>
<li><p>中级调度（Intermediate Scheduling）</p>
<p>中级调度又称为内存调度。引入中级调度的目的是，提高内存利用率和系统吞吐量。为此，应把那些暂时不能运行的进程，调至外存等待，此时进程的状态称为就绪驻外存状态（挂起状态）。当它们已具备运行条件且内存又稍有空闲时，由中级调度来决定，把外存上的哪些已具备运行条件的就绪进程再重新调入内存，并修改其状态为就绪状态，挂在就绪队列上等待。</p>
</li>
</ol>
<h3 id="处理机调度算法的目标"><a href="#处理机调度算法的目标" class="headerlink" title="处理机调度算法的目标"></a>处理机调度算法的目标</h3><ol>
<li>资源利用率。为提高系统的资源利用率，应使用系统中的处理机和其它所有资源都尽可能地保持忙碌状态，其中最重要的处理机利用率可用以下方法计算：CPU利用率 = CPU有效工作时间 / （CPU有效工作时间 + CPU空闲等待时间）。</li>
<li>公平性。公平性是指应使诸进程都获得合理的CPU时间，不会发生进程饥饿现象。公平性是相对的，对相同类型的进程应获得相同的服务；但对于不同类型的进程，由于其紧急程度或重要性的不同，则应提供不同的服务。</li>
<li>平衡性。由于系统中可能具有多种类型的进程，有的属于计算型作业，有的属于I/O型，为使系统中的CPU和各种外部设备都能经常处于忙碌状态，调度算法应尽可能保持系统资源使用的平衡性。</li>
<li>策略强制执行。对所制订的策略其中包括安全策略，只要需要，就必须予以准确地执行，即使会造成某些工作的延迟也要执行。</li>
</ol>
<h2 id="作业与作业调度"><a href="#作业与作业调度" class="headerlink" title="作业与作业调度"></a>作业与作业调度</h2><blockquote>
<p>在多道批处理系统中，<strong>作业是用户提交给系统的一项相对独立的工作</strong>。操作员把用户提交的作业通过相应的输入设备输入到磁盘存储盘，并保存在一个后备作业队列中。再由作业调度程序将其从外存调入内存。</p>
</blockquote>
<h3 id="批处理系统中的作业是什么"><a href="#批处理系统中的作业是什么" class="headerlink" title="批处理系统中的作业是什么"></a>批处理系统中的作业是什么</h3><p>作业。作业是一个比程序更为广泛的概念，它不仅包含了通常的程序和数据，而且还应配有一份作业说明书，系统根据该说明书来对程序的运行进行控制。在批处理系统中，是以作业为基本单位从外存调入内存的。</p>
<blockquote>
<p>通常在作业运行期间，每个作业都必须经过若干个相对独立，又互相关联的顺序加工步骤才能得到结果。我们把其中的每一个加工步骤称为一个作业步（Job Step），各作业步之间存在着相互联系，往往上一个作业步的输出作为下一个作业步的输入。</p>
<p>比如一个典型的作业可分成：”编译”–&gt;”链接装配”–&gt;”运行”。</p>
</blockquote>
<h3 id="作业控制块（Job-Control-Block，JCB）"><a href="#作业控制块（Job-Control-Block，JCB）" class="headerlink" title="作业控制块（Job Control Block，JCB）"></a>作业控制块（Job Control Block，JCB）</h3><ol>
<li>作业控制块（JCB）:JCB用来唯一地标识作业并记录所有与作业相关的信息。</li>
<li>相关信息：<ul>
<li>作业标识：操作系统用来区分每一个作业。</li>
<li>用户标识：创建作业的用户名称及帐号。</li>
<li>估计运行时间：预计的作业需要占用CPU的时间。</li>
<li>优先数：在作业调度时，能反应该作业被调度的机会。</li>
<li>作业创建时间：作业从提交状态变为后备状态的时间。</li>
<li>作业状态：代表作业在系统中所处的状态。</li>
<li>作业地址：作业在系统中的存放位置。</li>
<li>作业对其他资源的要求：如存储器要求、设备要求、文件及数据的要求等。</li>
</ul>
</li>
</ol>
<h3 id="作业运行的三个阶段和三种状态"><a href="#作业运行的三个阶段和三种状态" class="headerlink" title="作业运行的三个阶段和三种状态"></a>作业运行的三个阶段和三种状态</h3><blockquote>
<p>作业从进入系统到运行结束，通过需要经历收容、运行和完成三个阶段。相应的作业也就有“后备状态”，“运行状态”和“完成状态”。</p>
</blockquote>
<ol>
<li>收容阶段。操作员把用户提交的作业通过某种输入方式或SPOOLing系统输入到硬盘上，再为该作业建立JCB，并把它放入作业后备队列中。相应地、此时作业的状态为“后备状态”。</li>
<li>运行阶段。当作业被作业调度选中后，便为它分配必要的资源和建立进程，并将它放入就绪队列。一个作业从第一次进入就绪状态开始，直到它运行结束前，在此期间都处于“运行状态”。</li>
<li>完成阶段。当作业运行完成、或者发生异常情况而提前结束时，作业便进入完成阶段，相应的作业状态为“完成状态”。此时系统中的“终止作业”程序会回收已分配给该作业的作业控制块和所有资源，并将作业运行结果信息形成输出文件后输出。</li>
</ol>
<h3 id="作业调度的主要任务"><a href="#作业调度的主要任务" class="headerlink" title="作业调度的主要任务"></a>作业调度的主要任务</h3><p>作业调度的主要任务是根据JCB中的信息，检查系统中的资源能否满足作业对资源需求，以及按照一定的调度算法，从外存的后备队列中选取某些作业调入内存，并为它们创建进程、分配必要的资源。然后再将新创建的进程排在就绪队列上等待调度。因此也把作业调度称为接纳调度（Admission Scheduling）。在每次执行作业调度时，都需做出以下两个决定：接纳多少个作业、接纳哪些作业。</p>
<h3 id="作业调度的调度算法"><a href="#作业调度的调度算法" class="headerlink" title="作业调度的调度算法"></a>作业调度的调度算法</h3><ol>
<li><p>先来先服务FCFS（该算法即可用于作业调度和进程调度）</p>
<p>根据作业到达的先后次序安排作业的执行顺序，最先到达的作业最先执行.</p>
<p>该算法操作最简单，同时看起来也是最公平，因此在系统中都有应用，但是它没有考虑作业运行时间的长短，如果最先到达的作业需要较长的时间，而稍后到达的作业只需要很短的运行时间，就会导致短作业的长时间等待，使短作业的带权周转的时间增大，而长作业的带权周转时间较小，因此造成长短作业处于事实上的不公平状态。</p>
</li>
<li><p>短作业优先法SJF</p>
<p>根据作业提出的运行时间的长短来安排调度顺序，最短的作业最先被调度进入执行状态。</p>
<p>显然这是一种照顾短作业的方法，它降低短作业的带权周转时间，却提高了长作业的带权周转时间，对整个系统来说，短作业优先算法可以提高系统的吞吐能力，加块系统的响应时间，但它未考虑在响应时间上的公平，短作业虽然有短的响应时间，但如果系统短作业过多，长作业则会有过长的等待时间。</p>
</li>
<li><p>优先级调度算法PSA（该算法即可用于作业调度和进程调度）</p>
<p>对于 FCFS，等待时间是优先级。对于 SJF，作业的长短是优先级。</p>
<p>PSA基于作业的紧迫程度，由外部赋予作业相应的优先级，系统选择优先级最高的几个作业装入内存。这样就可以保证紧迫性作业优先运行。当把该算法用于作业调度时，系统是从后备队列中选择若干个优先级最高的作业装入内存。</p>
</li>
<li><p>最高响应比优先HRRN</p>
<p>FCFS 只考虑了作业的等待时间，忽略了运行时间。SJF 只考虑了作业的运行时间，忽略了等待时间。</p>
<p>HRRN 既考虑了作业的等待时间，也考虑了作业的运行时间，是一种动态优先级调度算法。</p>
<p><em><strong>响应比 = 周转时间 / 运行时间 =（运行时间 + 等待时间）/ 运行时间 = 1 + 等待时间 / 运行时间</strong></em>。</p>
<p>由上式可知，等待时间越长，响应比越高，因此，等待时间长的作业将优先获得运行，运行时间越长，响应比越低，因此，运行时间长的作业优先级将降低，这样就照顾了那些运行时间少而等待时间长的作业，但是每个作业的响应比随时都在发生变化，因此要不断的重新计算，如何确定重新计算的时间间隔是一个难处理的问题，时间间隔太短，将导致大量的计算开销，时间间隔太长，响应比的作用会下降。</p>
</li>
</ol>
<h2 id="进程调度的方式——抢占式与非抢占式"><a href="#进程调度的方式——抢占式与非抢占式" class="headerlink" title="进程调度的方式——抢占式与非抢占式"></a>进程调度的方式——抢占式与非抢占式</h2><blockquote>
<p>进程调度的运行频率是最高的，在分时系统中通常仅仅10~100ms就会进行一次。为避免调度这个行为本身占据太多的CPU时间，</p>
</blockquote>
<p>早期所采用的非抢占方式存在着很大的局限性，很难满足交互性作业和实时任务的需求。为此，在进程调度中又引入了抢占方式。</p>
<p>所谓的<strong>非抢占方式</strong>，也就是一旦处理机分配给某进程后，就一直让它运行下去，决不会因为时钟中断或任何其他原因取抢占当前正在运行进程的处理机，直至该进程完成，或发生某事件而阻塞时，才把处理及分配给其它进程。</p>
<p>所谓的<strong>抢占方式</strong>，也就是允许调度程序根据某种原则，去暂停某个正在执行的进程，将已分配给该进程的处理机重新分配给另一进程。</p>
<ol>
<li><p><strong>最短剩余时间优先 shortest remaining time next（SRTN）</strong></p>
<p>最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p>
</li>
<li><p><strong>时间片轮转 round robin（RR）</strong></p>
<p>将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。</p>
<p>时间片轮转算法的效率和时间片的大小有很大关系：</p>
<ul>
<li>因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。</li>
<li>而如果时间片过长，那么实时性就不能得到保证。</li>
</ul>
</li>
<li><p><strong>优先级调度</strong></p>
<p>为每个进程分配一个优先级，按优先级进行调度。</p>
<p>为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p>
</li>
<li><p><strong>多级反馈队列</strong></p>
<p>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。</p>
<p>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。</p>
<p>每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。</p>
<p>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。</p>
</li>
</ol>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁是什么"><a href="#死锁是什么" class="headerlink" title="死锁是什么"></a>死锁是什么</h3><p>多个进程可以竞争有限数量的资源。当一个进程申请资源时，如果这时没有可用资源，那么这个进程进入等待状态。有时，如果所申请的资源被其他等待进程占有，那么该等待进程有可能再也无法改变状态。这种情况成为<strong>死锁</strong>。</p>
<blockquote>
<p>如果一组进程中的每一个进程都在等待仅由该组进程中的其它进程才能引发的事件，那么该组进程是死锁的。</p>
</blockquote>
<h3 id="死锁的必要条件"><a href="#死锁的必要条件" class="headerlink" title="死锁的必要条件"></a>死锁的必要条件</h3><ul>
<li><strong>互斥</strong>：资源必须处于非共享模式，即一次只有一个进程可以使用。如果另一进程申请该资源，那么必须等待直到该资源被释放为止。</li>
<li><strong>占有并等待</strong>：一个进程至少应该占有一个资源，并等待另一资源，而该资源被其他进程所占有。</li>
<li><strong>非抢占</strong>：资源不能被抢占。只能在持有资源的进程完成任务后，该资源才会被释放。</li>
<li><strong>循环等待</strong>：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。例如有一组等待进程 <code>&#123;P0, P1,..., Pn&#125;</code>， <code>P0</code> 等待的资源被 <code>P1</code> 占有，<code>P1</code> 等待的资源被 <code>P2</code> 占有，……，<code>Pn-1</code> 等待的资源被 <code>Pn</code> 占有，<code>Pn</code> 等待的资源被 <code>P0</code> 占有。</li>
</ul>
<h3 id="死锁的处理方式——鸵鸟策略"><a href="#死锁的处理方式——鸵鸟策略" class="headerlink" title="死锁的处理方式——鸵鸟策略"></a>死锁的处理方式——鸵鸟策略</h3><p>把头埋在沙子里，假装根本没发生问题。</p>
<p>因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。</p>
<h3 id="死锁的处理方式——预防死锁"><a href="#死锁的处理方式——预防死锁" class="headerlink" title="死锁的处理方式——预防死锁"></a>死锁的处理方式——预防死锁</h3><p>在程序运行之前预防发生死锁，破坏死锁发生的四个条件。</p>
<ol>
<li><p>破坏互斥条件（<strong>一般来说，互斥条件是非共享设备所必须的，不仅不能改变，还应加以保证，因此主要是破坏产生死锁的后三个条件</strong>）。</p>
</li>
<li><p>破坏占有和等待条件：一种实现方式是规定所有进程在开始执行前请求所需要的全部资源，还有一种实现方式是允许一个进程只获得运行初期所需的资源后便开始运行。</p>
</li>
<li><p>破坏不可抢占条件：即当进程新的资源未得到满足时，释放已占有的资源，从而破坏不可抢占的条件（<strong>该方法实现起来比较复杂，且需付出很大的代价</strong>）。</p>
</li>
<li><p>破坏环路等待：对系统所有资源类型进行线性排序，并赋予不同的序号，比如规定每个进程必须按序号递增的顺序请求资源。</p>
</li>
</ol>
<h3 id="死锁的处理方式——避免死锁"><a href="#死锁的处理方式——避免死锁" class="headerlink" title="死锁的处理方式——避免死锁"></a>死锁的处理方式——避免死锁</h3><blockquote>
<p>在程序运行时避免发生死锁，即在资源动态分配过程中，防止系统进入不安全状态。</p>
</blockquote>
<p><strong>安全状态</strong></p>
<p><img src="https://gitee.com/Satoshi1130/picture/raw/master/cover/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%89%E5%85%A8%E7%8A%B6%E6%80%81%E5%9B%BE2.jpg" alt="操作系统-安全状态图2"></p>
<p>图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，<strong>因此可以称图 a 所示的状态是安全的</strong>。</p>
<p><strong>如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的</strong>。</p>
<p>安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。下面的银行家算法与死锁检测算法非常类似，可以结合着做参考对比。</p>
<p><strong>单个资源的银行家算法</strong></p>
<blockquote>
<p>一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。</p>
</blockquote>
<p><img src="https://gitee.com/Satoshi1130/picture/raw/master/cover/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%8D%95%E4%B8%AA%E8%B5%84%E6%BA%90%E7%9A%84%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95.jpg" alt="操作系统-单个资源的银行家算法"></p>
<p>上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。</p>
<p><strong>多个资源的银行家算法</strong></p>
<p><img src="https://gitee.com/Satoshi1130/picture/raw/master/cover/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%A4%9A%E4%B8%AA%E8%B5%84%E6%BA%90%E7%9A%84%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95.jpg" alt="操作系统-多个资源的银行家算法"></p>
<p>上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资 源，注意这三个为向量，而不是具体数值，例如 A=(1020)，表示 4 个资源分别还剩下 1/0/2/0。</p>
<p>检查一个状态是否安全的算法如下：</p>
<ul>
<li>查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。</li>
<li>假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。</li>
<li>重复以上两步，直到所有进程都标记为终止，则状态时安全的。</li>
</ul>
<p>如果一个状态不是安全的，需要拒绝进入这个状态。</p>
<h3 id="死锁的处理方式——检测与解除死锁"><a href="#死锁的处理方式——检测与解除死锁" class="headerlink" title="死锁的处理方式——检测与解除死锁"></a>死锁的处理方式——检测与解除死锁</h3><p>不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。</p>
<p>那么为了能对系统中是否已发生了死锁进行检测，在系统中必须保存有关资源的请求和分配信息并提供一种算法，它利用这些信息来检测系统是否已进入死锁状态（算法比较复杂就不继续深入了）。</p>
<p>死锁的解除主要是抢占资源或这个终止进程。</p>
<hr>
<h1 id="基础知识——存储器管理与虚拟存储器"><a href="#基础知识——存储器管理与虚拟存储器" class="headerlink" title="基础知识——存储器管理与虚拟存储器"></a>基础知识——存储器管理与虚拟存储器</h1><blockquote>
<p>存储器的管理的对象主要是内存。</p>
</blockquote>
<h3 id="存储器管理"><a href="#存储器管理" class="headerlink" title="存储器管理"></a><strong>存储器管理</strong></h3><p>通俗的讲，存储器管理就是计算机在程序运行时，在内存中为程序分配内存的方式。<br>存储器管理的方式包括传统的存储器管理方式和被广泛应用且优越的使用虚拟存储器的方式。</p>
<h3 id="传统的存储器管理方式"><a href="#传统的存储器管理方式" class="headerlink" title="传统的存储器管理方式"></a>传统的存储器管理方式</h3><p>传统的存储器管理方式包括了连续分配存储管理方式、分页存储管理方式、分段存储管理方式和段页式存储管理方式。</p>
<p>（1）连续分配存储管理方式：程序被连续、整块地装入内存。</p>
<p>（2）分页存储管理方式：为了提高存储器（内存）的利用率，减少内存碎片的大小和出现概率，将程序的地址空间被分为许多大小相同的页（2的幂，1~8KB），而内存也同样被分为许多大小相同的块（也叫物理块，与页的大小相同）。把程序调入内存时，就把程序的页装入内存的块中，实现用户程序在内存中的离散分配。那么为了管理程序的被离散分配的页，系统为每一个进程引入一个叫做页表的数据结构（表），用于建立页和块的映射关系，进程在执行时可以找到程序的每页在内存中的块号。<br>借助于页表，可以完成地址变换的任务，而为了提高地址变换的效率，引入了叫做快表的缓冲寄存器，来缓存地址变换的运算结果。此外，还引入了两级页表和三级页表来解决页表规模太大的问题。</p>
<p>（3）分段存储管理方式：分页存储管理方式为了提高内存利用率，将程序分为了一个个大小相同的页，一个函数可能被分为了若干页；而分段存储管理方式则是将程序按照程序中各部分的逻辑关系，将程序分为大小不同的段，比如主程序段、子程序段A、子程序段B、数据段、栈段等。段成为了信息的逻辑单位。<br>在编址方式上，分页存储管理方式中的各个页的地址是连续的，页内的地址对应的就是物理地址（当然是相对的），而分段存储管理方式中的各个段，每个段从0开始编址。<br>分段存储管理方式的好处体现在方便编程、信息共享、信息保护、动态增长、动态链接等方面。分段存储管理方式同样引入了类似于页表的段表。</p>
<p>（4）段页式存储管理方式：结合了分页存储管理方式和分段存储管理方式的存储器管理方式，通俗的说，就是在分段的基础上，把每段程序来分页。在段表中添加引用了每段程序的页表的引用，很好理解。</p>
<h3 id="虚拟存储器（通俗的讲，虚拟内存）"><a href="#虚拟存储器（通俗的讲，虚拟内存）" class="headerlink" title="虚拟存储器（通俗的讲，虚拟内存）"></a>虚拟存储器（通俗的讲，虚拟内存）</h3><p>传统的存储器管理方式都需要将程序一次性地装入内存，并且需要程序在运行期间驻留在内存中，且不会被换出至外存。显而易见传统的方式使得程序占据大量内存，非常浪费内存资源，虚拟存储技术可以很好地解决这个问题。<br>虚拟存储技术是一种允许程序在运行时，仅将能够运行的最少的页（段）调入内存，并允许程序剩下的页（段）在程序需要使用时才调入内存的技术。它利用了程序的局部性原理，减小了程序在内存中的占用，允许了内存中运行更多的程序，无形之中让人产生了内存好像变大了的错觉，而这种内存的扩充是虚拟出来的，因此叫做虚拟存储。逻辑上的容量由内存外存之和决定。<br>虚拟存储器的存储系统必须具备（将页或段）请求调入（内存）和置换功能。请求调入，指程序访问未被调入的页（段）时，发出缺页（段）请求，让操作系统将缺页（段）的调入内存。光是调入还不够，虚拟存储器还需要能够将已调入的、暂时不会运行的页（段）换至外存的能力。<br>虚拟存储器的特点是多次性（多次调入，最重要）、对换性（允许进程、作业被换进或换出）和虚拟性（建立在前两者之上）。</p>
<h3 id="实现虚拟存储器"><a href="#实现虚拟存储器" class="headerlink" title="实现虚拟存储器"></a>实现虚拟存储器</h3><p>实现虚拟存储器需要实现请求调入和置换功能。主要实现方式有请求分页系统（换进换出的页大小固定，因此更简单）和请求分段系统等。<br>以请求分页系统为例，除了内存外存外，还需要提供请求页表机制、缺页中断机构以及地址变换机构。其中，请求页表时，有两种分配内存的机制，一是局部置换，将程序自身的部分换出，不影响其他程序，二是全局置换，为程序提供新的物理块（增加运行内存）。</p>
<h3 id="请求分页系统的页面置换算法"><a href="#请求分页系统的页面置换算法" class="headerlink" title="请求分页系统的页面置换算法"></a>请求分页系统的页面置换算法</h3><p>页面置换算法是请求分页系统选择换出页的算法，非常重要，其好坏直接影响系统的性能。<br>（1）最佳置换算法：仅理论存在，是在选择换出页时，每次都选择在未来最长时间访问不到的页。<br>（2）FIFO先进先出算法：性能最差，先进入内存的先出去。<br>（3）最近最少使用算法（Least Recently Used）和最少使用算法（Least Frequency Used）<br>（5）Clock置换算法（LRU的近似算法）：利用每个页的访问和修改的标记，优先选择最近未被访问且未被修改的页换出，其次是未访问已修改、已访问未修改、已访问已修改。<br>（6）页面缓冲算法：不实际将页面换出至外存，而是放在空闲块中，由空闲页面链表管理。</p>
<h3 id="抖动"><a href="#抖动" class="headerlink" title="抖动"></a>抖动</h3><p>抖动指页面被刚换出就需要被换进，这种频繁的缺页的现象。<br>出现原因是并发的进程太多，系统给每个进程提供的物理块（内存）太少，进程运行中频繁缺页，导致每个进程的大部分时间都拿去请求调入缺的页去了，处理机效率直线下降甚至趋近于0。解决这个问题的方法有局部置换策略（只局部置换，不请求新的块）、选择暂停的进程等。</p>
<h3 id="请求分段系统"><a href="#请求分段系统" class="headerlink" title="请求分段系统"></a>请求分段系统</h3><p>请求分页系统建立在分页的基础上，而请求分段系统建立在分段的基础上，机制和请求分页系统很相似。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">ZouYe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://satoshi1130.github.io/MyBlog/2020/12/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">https://satoshi1130.github.io/MyBlog/2020/12/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://satoshi1130.github.io/MyBlog" target="_blank">Zy`s Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/MyBlog/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a><a class="post-meta__tags" href="/MyBlog/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></div><div class="post_share"><div class="social-share" data-image="https://img1.baidu.com/it/u=717294809,2494697366&amp;fm=26&amp;fmt=auto&amp;gp=0.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/MyBlog/2020/06/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><img class="next-cover" src="https://img2.baidu.com/it/u=371141290,1505999839&amp;fm=26&amp;fmt=auto&amp;gp=0.jpg" onerror="onerror=null;src='/MyBlog/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">初探数据结构与算法</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/MyBlog/2020/06/17/数据结构与算法/" title="初探数据结构与算法"><img class="cover" src="https://img2.baidu.com/it/u=371141290,1505999839&fm=26&fmt=auto&gp=0.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-06-17</div><div class="title">初探数据结构与算法</div></div></a></div><div><a href="/MyBlog/2020/06/08/计算机网络/" title="初探计算机网络"><img class="cover" src="https://img2.baidu.com/it/u=371141290,1505999839&fm=26&fmt=auto&gp=0.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-06-08</div><div class="title">初探计算机网络</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://gitee.com/Satoshi1130/picture/raw/master/cover/%E7%94%B7%E7%94%9F%E5%A4%B4%E5%83%8F1.jpg" onerror="this.onerror=null;this.src='/MyBlog/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">ZouYe</div><div class="author-info__description">自己的小博客，记录学习生活</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/MyBlog/archives/"><div class="headline">文章</div><div class="length-num">3</div></a></div><div class="card-info-data-item is-center"><a href="/MyBlog/tags/"><div class="headline">标签</div><div class="length-num">4</div></a></div><div class="card-info-data-item is-center"><a href="/MyBlog/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Satoshi11130"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Satoshi1130" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1821018219@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">2.</span> <span class="toc-text">参考资料</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0"><span class="toc-number">3.</span> <span class="toc-text">基础知识——概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E7%AE%80%E4%BB%8B"><span class="toc-number">3.1.</span> <span class="toc-text">操作系统基本简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.1.1.</span> <span class="toc-text">什么是操作系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="toc-number">3.1.2.</span> <span class="toc-text">操作系统的目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD"><span class="toc-number">3.1.3.</span> <span class="toc-text">操作系统的主要功能</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">基础知识——进程和线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">4.1.</span> <span class="toc-text">进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C"><span class="toc-number">4.1.1.</span> <span class="toc-text">并发与并行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B"><span class="toc-number">4.1.2.</span> <span class="toc-text">什么是进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">4.1.3.</span> <span class="toc-text">进程的状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8C%82%E8%B5%B7%E6%93%8D%E4%BD%9C"><span class="toc-number">4.1.4.</span> <span class="toc-text">进程的挂起操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%82%E8%B5%B7%E6%93%8D%E4%BD%9C%E7%9A%84%E5%BC%95%E5%85%A5%E5%8E%9F%E5%9B%A0"><span class="toc-number">4.1.5.</span> <span class="toc-text">挂起操作的引入原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%82%E8%B5%B7%E6%93%8D%E4%BD%9C%E5%90%8E%E4%BA%94%E4%B8%AA%E5%9F%BA%E6%9C%AC%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.1.6.</span> <span class="toc-text">挂起操作后五个基本进程状态的转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="toc-number">4.1.7.</span> <span class="toc-text">进程的控制结构——进程控制块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%80%81%E5%92%8C%E7%94%A8%E6%88%B7%E6%80%81"><span class="toc-number">4.1.8.</span> <span class="toc-text">系统态和用户态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%80%81%E5%92%8C%E7%94%A8%E6%88%B7%E6%80%81%E7%9A%84%E8%BD%AC%E6%8D%A2%E6%96%B9%E5%BC%8F"><span class="toc-number">4.1.9.</span> <span class="toc-text">系统态和用户态的转换方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B4%E7%95%8C%E5%8C%BA%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">4.1.10.</span> <span class="toc-text">临界区是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E5%BA%94%E9%81%B5%E5%BE%AA%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-number">4.1.11.</span> <span class="toc-text">进程同步机制应遵循的规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F"><span class="toc-number">4.1.12.</span> <span class="toc-text">进程的同步方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">4.1.13.</span> <span class="toc-text">经典的进程同步问题——生产者与消费者问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98"><span class="toc-number">4.1.14.</span> <span class="toc-text">经典的进程同步问题——哲学家进餐问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94%E8%AF%BB%E8%80%85%E4%B8%8E%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">4.1.15.</span> <span class="toc-text">经典的进程同步问题——读者与写者问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">4.1.16.</span> <span class="toc-text">进程的通信方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.1.17.</span> <span class="toc-text">进程同步与进程通信的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-number">4.1.18.</span> <span class="toc-text">进程的上下文切换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E5%9C%BA%E6%99%AF"><span class="toc-number">4.1.19.</span> <span class="toc-text">进程的上下文切换场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.2.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">4.2.1.</span> <span class="toc-text">线程是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">4.2.2.</span> <span class="toc-text">进程和线程的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%86%85%E6%A0%B8%E7%BA%A7%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.2.3.</span> <span class="toc-text">用户级线程和内核级线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%86%85%E6%A0%B8%E7%BA%A7%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%BB%84%E5%90%88%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.4.</span> <span class="toc-text">用户级线程和内核级线程的组合方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">4.2.5.</span> <span class="toc-text">进程同步与线程同步有什么区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E2%80%94%E2%80%94%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81"><span class="toc-number">5.</span> <span class="toc-text">基础知识——处理机调度与死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">5.1.</span> <span class="toc-text">处理机调度的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E7%9A%84%E5%B1%82%E6%AC%A1"><span class="toc-number">5.1.1.</span> <span class="toc-text">处理机调度的层次</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="toc-number">5.1.2.</span> <span class="toc-text">处理机调度算法的目标</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A%E4%B8%8E%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6"><span class="toc-number">5.2.</span> <span class="toc-text">作业与作业调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E4%BD%9C%E4%B8%9A%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">5.2.1.</span> <span class="toc-text">批处理系统中的作业是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6%E5%9D%97%EF%BC%88Job-Control-Block%EF%BC%8CJCB%EF%BC%89"><span class="toc-number">5.2.2.</span> <span class="toc-text">作业控制块（Job Control Block，JCB）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A%E8%BF%90%E8%A1%8C%E7%9A%84%E4%B8%89%E4%B8%AA%E9%98%B6%E6%AE%B5%E5%92%8C%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="toc-number">5.2.3.</span> <span class="toc-text">作业运行的三个阶段和三种状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6%E7%9A%84%E4%B8%BB%E8%A6%81%E4%BB%BB%E5%8A%A1"><span class="toc-number">5.2.4.</span> <span class="toc-text">作业调度的主要任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">5.2.5.</span> <span class="toc-text">作业调度的调度算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E6%96%B9%E5%BC%8F%E2%80%94%E2%80%94%E6%8A%A2%E5%8D%A0%E5%BC%8F%E4%B8%8E%E9%9D%9E%E6%8A%A2%E5%8D%A0%E5%BC%8F"><span class="toc-number">5.3.</span> <span class="toc-text">进程调度的方式——抢占式与非抢占式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">5.4.</span> <span class="toc-text">死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">5.4.1.</span> <span class="toc-text">死锁是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-number">5.4.2.</span> <span class="toc-text">死锁的必要条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E2%80%94%E2%80%94%E9%B8%B5%E9%B8%9F%E7%AD%96%E7%95%A5"><span class="toc-number">5.4.3.</span> <span class="toc-text">死锁的处理方式——鸵鸟策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E2%80%94%E2%80%94%E9%A2%84%E9%98%B2%E6%AD%BB%E9%94%81"><span class="toc-number">5.4.4.</span> <span class="toc-text">死锁的处理方式——预防死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E2%80%94%E2%80%94%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="toc-number">5.4.5.</span> <span class="toc-text">死锁的处理方式——避免死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E2%80%94%E2%80%94%E6%A3%80%E6%B5%8B%E4%B8%8E%E8%A7%A3%E9%99%A4%E6%AD%BB%E9%94%81"><span class="toc-number">5.4.6.</span> <span class="toc-text">死锁的处理方式——检测与解除死锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86%E4%B8%8E%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">6.</span> <span class="toc-text">基础知识——存储器管理与虚拟存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86"><span class="toc-number">6.0.1.</span> <span class="toc-text">存储器管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E7%9A%84%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">6.0.2.</span> <span class="toc-text">传统的存储器管理方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%EF%BC%88%E9%80%9A%E4%BF%97%E7%9A%84%E8%AE%B2%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%EF%BC%89"><span class="toc-number">6.0.3.</span> <span class="toc-text">虚拟存储器（通俗的讲，虚拟内存）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">6.0.4.</span> <span class="toc-text">实现虚拟存储器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">6.0.5.</span> <span class="toc-text">请求分页系统的页面置换算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%96%E5%8A%A8"><span class="toc-number">6.0.6.</span> <span class="toc-text">抖动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%88%86%E6%AE%B5%E7%B3%BB%E7%BB%9F"><span class="toc-number">6.0.7.</span> <span class="toc-text">请求分段系统</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/MyBlog/2020/12/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="初探操作系统"><img src="https://img1.baidu.com/it/u=717294809,2494697366&amp;fm=26&amp;fmt=auto&amp;gp=0.jpg" onerror="this.onerror=null;this.src='/MyBlog/img/404.jpg'" alt="初探操作系统"/></a><div class="content"><a class="title" href="/MyBlog/2020/12/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="初探操作系统">初探操作系统</a><time datetime="2020-12-29T05:49:18.000Z" title="发表于 2020-12-29 13:49:18">2020-12-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/MyBlog/2020/06/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" title="初探数据结构与算法"><img src="https://img2.baidu.com/it/u=371141290,1505999839&amp;fm=26&amp;fmt=auto&amp;gp=0.jpg" onerror="this.onerror=null;this.src='/MyBlog/img/404.jpg'" alt="初探数据结构与算法"/></a><div class="content"><a class="title" href="/MyBlog/2020/06/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" title="初探数据结构与算法">初探数据结构与算法</a><time datetime="2020-06-17T11:29:35.000Z" title="发表于 2020-06-17 19:29:35">2020-06-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/MyBlog/2020/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="初探计算机网络"><img src="https://img2.baidu.com/it/u=371141290,1505999839&amp;fm=26&amp;fmt=auto&amp;gp=0.jpg" onerror="this.onerror=null;this.src='/MyBlog/img/404.jpg'" alt="初探计算机网络"/></a><div class="content"><a class="title" href="/MyBlog/2020/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="初探计算机网络">初探计算机网络</a><time datetime="2020-06-08T06:36:04.000Z" title="发表于 2020-06-08 14:36:04">2020-06-08</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By ZouYe</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/MyBlog/js/utils.js"></script><script src="/MyBlog/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>